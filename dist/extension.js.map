{"version":3,"sources":["../src/extension.ts","../src/wordcount.ts","../src/completion.ts","../src/nodemap.ts","../src/definitions.ts"],"sourcesContent":["'use strict';\r\n/* Ink for VS Code Extension Main File */\r\n\r\nimport { ExtensionContext, DocumentFilter, ProgressLocation, languages, window } from \"vscode\";\r\nimport { WordAndNodeCounter, WordNodeCounterController } from \"./wordcount\";\r\nimport { DivertCompletionProvider } from \"./completion\";\r\nimport * as NodeMap from \"./nodemap\";\r\nimport { InkDivertDefinitionProvider } from \"./definitions\";\r\n\r\nconst INK : DocumentFilter = { language: 'ink' };\r\n\r\nexport function activate(ctx: ExtensionContext) {\r\n\r\n    // Create a new word counter.\r\n    const wordCounter = new WordAndNodeCounter();\r\n    const wcController = new WordNodeCounterController(wordCounter);\r\n    const nodeMapController = new NodeMap.NodeController();\r\n\r\n    // Start generating a node map.\r\n    window.withProgress({ location: ProgressLocation.Window, title: \"Mapping knots and stitches...\" }, NodeMap.generateMaps);\r\n\r\n    // Add to a list of disposables which are disposed when this extension is\r\n    // deactivated again.\r\n    ctx.subscriptions.push(wcController);\r\n    ctx.subscriptions.push(wordCounter);\r\n    ctx.subscriptions.push(nodeMapController);\r\n\r\n    // Enable the completion provider.\r\n    ctx.subscriptions.push(languages.registerCompletionItemProvider(INK, new DivertCompletionProvider(), '>', '-', ' '));\r\n\r\n    // Enable the definition provider.\r\n    ctx.subscriptions.push(languages.registerDefinitionProvider(INK, new InkDivertDefinitionProvider()));\r\n}","'use strict';\r\n\r\nimport { window, workspace, commands, Disposable, ExtensionContext, StatusBarAlignment, StatusBarItem, TextDocument } from \"vscode\";\r\n\r\n/* Provides word count functionality. Mostly adapted from the example\r\n    word counter extension.\r\n*/\r\nexport class WordAndNodeCounter {\r\n    private _statusBarItem: StatusBarItem;\r\n\r\n    private plural (n: number, word: string) : string {\r\n        return `${n} ${n === 1 ? word : `${word}s`}`;\r\n    }\r\n\r\n    public updateWordCount () {\r\n        // Create this as needed.\r\n        if (!this._statusBarItem)\r\n            this._statusBarItem = window.createStatusBarItem(StatusBarAlignment.Left);\r\n        \r\n        // Get the current text editor.\r\n        let editor = window.activeTextEditor;\r\n        if (!editor) {\r\n            this._statusBarItem.hide();\r\n            return;\r\n        }\r\n\r\n        let doc = editor.document;\r\n\r\n        // Only update status if an Ink file.\r\n        if (doc.languageId === \"ink\") {\r\n            const docContent = doc.getText();\r\n            const wordCount = this._getWordCount(docContent);\r\n            const nodeCount = this._getNodeCount(docContent);\r\n\r\n\r\n            // Update the status bar, finally.\r\n            this._statusBarItem.text = `$(pencil) ${this.plural(wordCount, \"Word\")} in ${this.plural(nodeCount, \"Node\")}`;\r\n            this._statusBarItem.show();\r\n        } else {\r\n            this._statusBarItem.hide();\r\n        }\r\n    }\r\n\r\n    private static lineReducer (stack: { scope: string, lines: string[]}, line: string): { scope: string, lines: string[] } {\r\n        // Reducer function to remove undesirable lines and inline content.\r\n        let { scope, lines } = stack;\r\n        if (line.match(/^\\s*$/)) return stack; // Empty line\r\n        if (scope === \"multiline\") { // Continuing multiline { block }\r\n            if (line.match(/\\}/) !== null) {\r\n                scope = \"root\";\r\n                // Add just the part of the line after the }, if anything.\r\n                return WordAndNodeCounter.lineReducer({ scope, lines }, (line.match(/}(.*)/)[1]));\r\n            }\r\n            return stack;\r\n        }\r\n        if (scope === \"comment\") { // Continuing multiline comment\r\n            if (line.match(/\\*\\//) !== null) {\r\n                scope = \"root\";\r\n                return WordAndNodeCounter.lineReducer({ scope, lines }, (line.match(/\\*\\/(.*)/)[1]));\r\n            }\r\n            return stack;\r\n        }\r\n        if (line.match(/\\{/) !== null) { // Start of { block }\r\n            if (line.match(/\\}/) !== null)\r\n                return WordAndNodeCounter.lineReducer(stack, line.replace(/\\{.*\\}/, \"\"));\r\n            scope = \"multiline\";\r\n            return { scope, lines };\r\n        }\r\n        if (line.match(/\\/\\//) !== null) { // // Comment\r\n            return WordAndNodeCounter.lineReducer(stack, line.replace(/\\/\\/.*/, \"\"));\r\n        }\r\n        if (line.match(/\\/\\*/)) { // Start of /* comment\r\n            if (line.match(/\\*\\//)) {\r\n                return WordAndNodeCounter.lineReducer(stack, line.replace(/\\/\\*.*\\*\\//, \"\"));\r\n            }\r\n            scope = \"comment\";\r\n            return { scope, lines };\r\n        }\r\n        // Various single-line directives/statements to ignore in wc\r\n        if (line.match(/^\\s*(~|=|VAR|EXTERNAL|INCLUDE)/) === null) {\r\n            lines.push(line);\r\n        }\r\n        return { scope, lines };\r\n    }\r\n\r\n    public _getWordCount (docContent: string): number {\r\n\r\n        // TODO: Write code for accurate word count of Ink document.\r\n        // TODO: Add node count.\r\n\r\n        /* We want an *accurate* word count, so we want to ignore things like knot identifiers\r\n         * as much as possible. Consequently, we must go line by line and identify any lines\r\n         * that should not be counted. */\r\n\r\n\r\n        return docContent.split(\"\\n\").reduce(WordAndNodeCounter.lineReducer, { scope: 'root', lines: [] })\r\n            .lines\r\n            .join(\" \")\r\n            .split(/\\s/)\r\n            .filter(word => word.match(/\\w/))\r\n            .length;\r\n    }\r\n\r\n    public _getNodeCount (docContent: string): number {\r\n        return docContent.split(\"\\n\").filter(line => line.match(/^\\s*=/)).length;\r\n    }\r\n\r\n    public dispose() {\r\n        this._statusBarItem.dispose();\r\n    }\r\n}\r\n\r\nexport class WordNodeCounterController {\r\n    private _wordCounter: WordAndNodeCounter;\r\n    private _disposable: Disposable;\r\n\r\n    constructor (wordCounter: WordAndNodeCounter) {\r\n        this._wordCounter = wordCounter;\r\n        this._wordCounter.updateWordCount();\r\n\r\n        // Subscribe to selection change and editor activation events.\r\n        let subscriptions: Disposable[] = [];\r\n        window.onDidChangeTextEditorSelection(this._onEvent, this, subscriptions);\r\n        window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions);\r\n\r\n        // Create a combined disposable from both event subscriptions.\r\n        this._disposable = Disposable.from(...subscriptions);\r\n    }\r\n\r\n    private _onEvent () {\r\n        this._wordCounter.updateWordCount();\r\n    }\r\n\r\n    public dispose () {\r\n        this._disposable.dispose();\r\n    }\r\n}","import { CompletionItemProvider, TextDocument, Position, CancellationToken, CompletionItem, Range, CompletionItemKind, workspace } from \"vscode\";\r\nimport * as NodeMap from \"./nodemap\";\r\nimport * as fs from \"fs\";\r\n\r\nexport class DivertCompletionProvider implements CompletionItemProvider {\r\n\r\n    public provideCompletionItems (document: TextDocument, position: Position) : CompletionItem[] {\r\n        // Make sure we are at the end of a valid divert arrow.\r\n        // Ignore a > at the start of a line.\r\n        const before = document.getText(new Range(position.with(position.line, 0), position));\r\n        if (!/(->|<-) ?$/.test(before)) return;\r\n        if (/-> ?-> ?$/.test(before)) return;\r\n        return NodeMap.getDivertCompletionTargets(document.uri.fsPath, position.line);\r\n    }\r\n\r\n}","import {\r\n    Uri, Position, CompletionItem, CompletionItemKind, Disposable,\r\n    Location, TextDocument, TextDocumentChangeEvent,\r\n    workspace\r\n} from \"vscode\";\r\nimport * as fs from \"fs\";\r\nimport * as path from \"path\";\r\n\r\n/* Divert targets that are always valid. */\r\nconst PERMANENT_DIVERTS = [\r\n    new CompletionItem(\"END\", CompletionItemKind.Keyword),\r\n    new CompletionItem(\"DONE\", CompletionItemKind.Keyword),\r\n    new CompletionItem(\"->\", CompletionItemKind.Keyword)\r\n]\r\n\r\nclass DivertTarget {\r\n    constructor(public readonly name: string | null) { }\r\n    public get line(): number {\r\n        throw new Error(\"line accessor must be overridden in subclass\");\r\n\r\n    };\r\n    public get parentFile(): NodeMap {\r\n        throw new Error(\"parentFile accessor must be implemented in subclass\");\r\n    }\r\n    public toCompletionItem(): CompletionItem {\r\n        return new CompletionItem(this.name, CompletionItemKind.Reference);\r\n    }\r\n}\r\n\r\nclass LabelNode extends DivertTarget {\r\n\r\n    public get line() {\r\n        return this._line + this.parentStitch.startLine;\r\n    }\r\n\r\n    public get parentFile() {\r\n        return this.parentStitch.parentKnot.parentFile;\r\n    }\r\n\r\n    constructor(\r\n        public readonly name: string,\r\n        private readonly _line: number,\r\n        public readonly parentStitch: StitchNode\r\n    ) {\r\n        super(name);\r\n    }\r\n\r\n\r\n}\r\n\r\nclass StitchNode extends DivertTarget {\r\n    public readonly labels: LabelNode[]\r\n\r\n    public get line() {\r\n        return this.startLine;\r\n    }\r\n\r\n    public get startLine() {\r\n        return this.parentKnot.startLine + this._relativeStart;\r\n    }\r\n\r\n    public get parentFile() {\r\n        return this.parentKnot.parentFile;\r\n    }\r\n\r\n    public get endLine() {\r\n        // On the last stich of the last knot in the file, we want the end line to actually be\r\n        // the next line after the end of the file. This is why we track whether we're on the\r\n        // last line or not when generating the map.\r\n        return this.parentKnot.startLine + this._relativeEnd + (this.lastLine ? 1 : 0);\r\n    }\r\n\r\n    constructor(\r\n        public readonly name: string,\r\n        private readonly _relativeStart: number,\r\n        private readonly _relativeEnd: number,\r\n        public readonly parentKnot: KnotNode,\r\n        textContent: string,\r\n        private readonly lastLine: boolean = false\r\n    ) {\r\n        super(name);\r\n        this.labels = textContent\r\n            .split(\"\\n\")\r\n            .map((line, index) => ({ found: line.match(/^\\s*[-\\*\\+]\\s*\\((\\w+)\\)/), index }))\r\n            .filter(({ found }) => found !== null)\r\n            .map(({ found, index }) => new LabelNode(found[1], index, this));\r\n    }\r\n}\r\n\r\nclass KnotNode extends DivertTarget {\r\n\r\n    public readonly stitches;\r\n\r\n    public get line() {\r\n        return this.startLine;\r\n    }\r\n\r\n    constructor(\r\n        public readonly name: string | null,\r\n        public readonly startLine: number,\r\n        public readonly endLine: number,\r\n        private readonly _parentFile: NodeMap,\r\n        textContent: string,\r\n        private readonly isFunction: boolean = false,\r\n        private readonly lastLine: boolean = false\r\n    ) {\r\n        super(name);\r\n        const lines = textContent.split(\"\\n\");\r\n        this.stitches = lines\r\n            .reduce((\r\n                { nodes, currentNode, lastStart, lastName }\r\n                    : { nodes: StitchNode[], currentNode: string[], lastStart: number, lastName: string | null }\r\n                , line: string\r\n                , index: number) => {\r\n                if (line.match(/^\\s*={1}\\s*(\\w+)/)) {\r\n                    // Found the start of a new stitch.\r\n                    const newName = line.match(/^\\s*={1}\\s*(\\w+)/)[1];\r\n                    const node = new StitchNode(lastName, lastStart, index, this, currentNode.join(\"\\n\"));\r\n                    nodes.push(node);\r\n                    if (index === lines.length - 1) {\r\n                        // The new stitch is also the last line of the knot.\r\n                        const node = new StitchNode(newName, index, index + 1, this, currentNode.join(\"\\n\"), this.lastLine);\r\n                        nodes.push(node);\r\n                    }\r\n                    return { nodes, currentNode: [line], lastStart: index, lastName: newName };\r\n                }\r\n                if (index === lines.length - 1) {\r\n                    // Found the last line.\r\n                    const node = new StitchNode(lastName, lastStart, index + 1, this, currentNode.join(\"\\n\"), this.lastLine);\r\n                    nodes.push(node);\r\n                    return { nodes, currentNode: [line], lastStart: index, lastName: null };\r\n                }\r\n                currentNode.push(line);\r\n                return { nodes, currentNode, lastStart, lastName };\r\n            }, { nodes: [], currentNode: [], lastStart: 0, lastName: null })\r\n            .nodes;\r\n    }\r\n\r\n    public get parentFile(): NodeMap {\r\n        return this._parentFile;\r\n    }\r\n\r\n    public toCompletionItem(): CompletionItem {\r\n        const itemKind = this.isFunction ? CompletionItemKind.Function : CompletionItemKind.Reference;\r\n        return new CompletionItem(this.name, itemKind);\r\n    }\r\n}\r\n\r\nclass NodeMap {\r\n\r\n    public readonly knots: KnotNode[];\r\n    public readonly includes: string[];\r\n\r\n    private constructor(public filePath: string, fileText: string) {\r\n        const lines = fileText.split(\"\\n\");\r\n        this.knots = lines\r\n            .reduce((\r\n                { nodes, currentNode, lastStart, lastName, isFunction }\r\n                    : { nodes: KnotNode[], currentNode: string[], lastStart: number, lastName: string | null, isFunction }\r\n                , line: string\r\n                , index: number) => {\r\n                if (line.match(/^\\s*===(\\s*function)?\\s*(\\w+)\\s*===/)) {\r\n                    // Found the start of a new knot.\r\n\r\n                    const match = line.match(/^\\s*===(\\s*function)?\\s*(\\w+)\\s*===/);\r\n                    const newName = match[2];\r\n                    const foundFunction = (!!match[1]);\r\n                    const node = new KnotNode(lastName, lastStart, index, this, currentNode.join(\"\\n\"), isFunction);\r\n                    nodes.push(node);\r\n                    return { nodes, currentNode: [line], lastStart: index, lastName: newName, isFunction: foundFunction };\r\n                }\r\n                if (index === lines.length - 1) {\r\n                    // Found the last line\r\n                    const node = new KnotNode(lastName, lastStart, index + 1, this, currentNode.concat(line).join(\"\\n\"), false, true);\r\n                    nodes.push(node);\r\n                    return { nodes, currentNode: [line], lastStart: index, lastName: null, isFunction };\r\n                }\r\n                currentNode.push(line);\r\n                return { nodes, currentNode, lastStart, lastName, isFunction };\r\n            }, { nodes: [], currentNode: [], lastStart: 0, lastName: null, isFunction: false })\r\n            .nodes;\r\n        this.includes = lines\r\n            .filter(line => line.match(/^\\s*INCLUDE\\s+(\\w+\\.ink)/))\r\n            .map(line => {\r\n                const filename = line.match(/^\\s*INCLUDE\\s+(\\w+\\.ink)/)[1];\r\n                const dirname = path.dirname(filePath);\r\n                return path.normalize(dirname + path.sep + filename);\r\n            });\r\n\r\n        console.log(\"Knots found:\", this.knots.map(k => k.name));\r\n    }\r\n\r\n    public static from(filePath: string): Promise<NodeMap> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            fs.readFile(filePath, 'utf8', (err, data: string) => {\r\n                if (err) return reject(err);\r\n                return resolve(data);\r\n            });\r\n        })\r\n            .catch((err) => console.log(\"Error opening file: \", err))\r\n            .then((data) => new NodeMap(filePath, data ? data : \"\"));\r\n    }\r\n\r\n    public static fromDocument(document: TextDocument): NodeMap {\r\n        const { fsPath } = document.uri;\r\n        return new NodeMap(fsPath, document.getText());\r\n    }\r\n}\r\n\r\nconst nodeMaps: { [key: string]: NodeMap; } = {};\r\nlet mapsDone: boolean = false;\r\n\r\nexport function generateMaps(): Thenable<void> {\r\n    return Promise.all([\r\n        workspace.findFiles(\"*.ink\"),       // root directory\r\n        workspace.findFiles(\"**/*.ink\")     // subdirectories\r\n    ])\r\n    .then(([rootFiles, subFiles]) => {\r\n        const allFiles = [...rootFiles, ...subFiles];\r\n\r\n        // deduplicate by fsPath\r\n        const uniqueFiles = Array.from(new Map(allFiles.map(f => [f.fsPath, f])).values());\r\n\r\n        return Promise.all(uniqueFiles.map(({ fsPath }) => NodeMap.from(fsPath)));\r\n    })\r\n    .then((maps: NodeMap[]) => {\r\n        maps.forEach(map => {\r\n            nodeMaps[map.filePath] = map;\r\n        });\r\n        mapsDone = true;\r\n    })\r\n    .catch(err => {\r\n        console.error(\"Error generating maps:\", err);\r\n    });\r\n}\r\n\r\n\r\nfunction getIncludeScope(filePath: string, knownScope: string[] = []): string[] {\r\n    const fileMap = nodeMaps[filePath];\r\n    if (!fileMap) return knownScope;\r\n    if (knownScope.indexOf(filePath) === -1) knownScope.push(filePath);\r\n    const newScope = fileMap.includes.filter(include => knownScope.indexOf(include) === -1);\r\n    if (newScope.length < 1) return knownScope;\r\n    return getIncludeScope(filePath, getIncludeScope(newScope[0], knownScope));\r\n\r\n}\r\n\r\nfunction stitchFor(filePath: string, line: number): StitchNode | null {\r\n    const nodemap = nodeMaps[filePath]\r\n    if (!nodemap) return null;\r\n    const knot = nodemap.knots.find(knot => knot.startLine <= line && knot.endLine > line);\r\n    if (!knot) {\r\n        console.log(\"Can't identify knot for line \", line);\r\n        return null;\r\n    }\r\n    const stitch = knot.stitches.find(stitch => stitch.startLine <= line && stitch.endLine > line);\r\n    if (!stitch) {\r\n        console.log(\"Can't identify stitch for line \", line);\r\n        return null;\r\n    }\r\n    return stitch;\r\n}\r\n\r\n/* Gets the divert names that are in scope for a given line and file. */\r\nfunction getDivertsInScope(filePath: string, line: number): DivertTarget[] {\r\n    if (nodeMaps[filePath]) {\r\n        let targets: DivertTarget[] = [];\r\n        const scope = getIncludeScope(filePath);\r\n        const knots = scope.map(path =>\r\n            nodeMaps[path]\r\n                .knots\r\n        )\r\n            .reduce((a, b) => a.concat(b));\r\n        targets = targets.concat(knots);\r\n        const currentStitch = stitchFor(filePath, line);\r\n        if (currentStitch) {\r\n            const stitches = currentStitch.parentKnot.stitches;\r\n            const labels = currentStitch.labels;\r\n            targets = targets.concat(stitches);\r\n            targets = targets.concat(labels);\r\n        } else {\r\n            console.log(\"WARN: Couldn't find current stitch for line \", line);\r\n        }\r\n\r\n        console.log(\"Diverts in scope for\", filePath, line, \"=>\", targets.map(t => t.name));\r\n        return targets;\r\n    }\r\n    console.log(`Node map missing for file ${filePath}`);\r\n    return [];\r\n}\r\n\r\nexport function getDefinitionByNameAndScope(name: string, filePath: string, line: number): Location {\r\n    let divert = getDivertsInScope(filePath, line)\r\n    .find(target => target.name === name);\r\n\r\n    if(!divert) {\r\n    for (const key in nodeMaps) {\r\n        const map = nodeMaps[key];\r\n        const targets = getDivertsInScope(map.filePath, line);\r\n        divert = targets.find(target => target.name === name);\r\n        if (divert) break;\r\n        }\r\n    }\r\n\r\n    if (!divert) {\r\n        throw new Error(`No divert target named '${name}' found in scope at ${filePath}:${line}`);\r\n    }\r\n    return new Location(Uri.file(divert.parentFile.filePath), new Position(divert.line, 0));\r\n}\r\n\r\n/* Returns completion items for divert target names for a given line and file. */\r\nexport function getDivertCompletionTargets(filePath: string, line: number): CompletionItem[] { \r\n    return getDivertsInScope(filePath, line)\r\n        .filter(target => target.name !== null)\r\n        .map(target => target.toCompletionItem())\r\n        .concat(PERMANENT_DIVERTS);\r\n}\r\n\r\nexport class NodeController {\r\n    private _disposable: Disposable;\r\n\r\n    constructor() {\r\n        let subscriptions: Disposable[] = [];\r\n        workspace.onDidChangeTextDocument(this._onEvent, this, subscriptions);\r\n\r\n        this._disposable = Disposable.from(...subscriptions);\r\n    }\r\n\r\n    private _onEvent({ contentChanges, document }: TextDocumentChangeEvent) {\r\n        // Don't rebuild the entire file unless we have a new line or special character\r\n        // suggesting the node map actually changed.\r\n        if (!contentChanges.find(change => change.text.match(/[\\n\\*\\+\\(\\)-=]/) !== null)) return;\r\n        const { fsPath } = document.uri;\r\n        nodeMaps[fsPath] = NodeMap.fromDocument(document);\r\n    }\r\n\r\n    public dispose() {\r\n        this._disposable.dispose();\r\n    }\r\n}","import {\r\n  DefinitionProvider,\r\n  Location,\r\n  TextDocument,\r\n  Position,\r\n  ProviderResult\r\n} from \"vscode\";\r\nimport { getDefinitionByNameAndScope } from \"./nodemap\";\r\n\r\nexport class InkDivertDefinitionProvider implements DefinitionProvider {\r\n  public provideDefinition(\r\n    document: TextDocument,\r\n    position: Position\r\n  ): ProviderResult<Location> {\r\n    // Get the line of text at the cursor\r\n    const line = document.lineAt(position.line).text;\r\n\r\n    // Combine characters before and after the cursor for full word detection\r\n    const cursorIndex = position.character;\r\n    const before = line.slice(0, cursorIndex);\r\n    const after = line.slice(cursorIndex);\r\n\r\n    // Match the name of the target node\r\n    const match = (before + after).match(/->\\s*([\\w.]+)/);\r\n    if (!match) return;\r\n\r\n    // Get the target node name\r\n    const name = match[1];\r\n    const [target] = name.split(\".\");\r\n\r\n    // Find the definition of the target node\r\n    return getDefinitionByNameAndScope(target, document.uri.fsPath, position.line);\r\n  }\r\n}\r\n"],"mappings":"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","names":["import_vscode","import_vscode","import_vscode","node","dirname","knot","stitch","path"]}