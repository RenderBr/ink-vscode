{"version":3,"sources":["../src/extension.ts","../src/controllers/NodeController.ts","../src/controllers/AbstractMapController.ts","../src/models/NodeMap.ts","../src/models/KnotNode.ts","../src/models/DivertTarget.ts","../src/models/LabelNode.ts","../src/models/StitchNode.ts","../src/providers/InkDivertDefinitionProvider.ts","../src/providers/InkFunctionDefinitionProvider.ts","../src/models/FunctionMap.ts","../src/controllers/FunctionController.ts","../src/providers/DivertCompletionProvider.ts","../src/providers/InkVariableDefinitionProvider.ts","../src/controllers/WordCountController.ts","../src/controllers/WordCounterService.ts"],"sourcesContent":["'use strict';\r\n/* Ink for VS Code Extension Main File */\r\n\r\nimport { ExtensionContext, DocumentFilter, ProgressLocation, languages, window } from \"vscode\";\r\nimport { InkDivertDefinitionProvider } from \"./providers/InkDivertDefinitionProvider\";\r\nimport { InkFunctionDefinitionProvider } from \"./providers/InkFunctionDefinitionProvider\";\r\nimport { DivertCompletionProvider } from \"./providers/DivertCompletionProvider\";\r\nimport { InkVariableDefinitionProvider } from \"./providers/InkVariableDefinitionProvider\";\r\nimport { generateNodeMaps, NodeController } from \"./controllers/NodeController\";\r\nimport { FunctionController, generateFunctionMaps } from \"./controllers/FunctionController\";\r\nimport { WordNodeCounterController } from \"./controllers/WordCountController\";\r\nimport { WordCounterService } from \"./controllers/WordCounterService\";\r\n\r\nconst INK : DocumentFilter = { language: 'ink' };\r\n\r\nexport function activate(context: ExtensionContext) {\r\n    const disposables = [];\r\n\r\n    // Services and controllers.\r\n    const wordCounter = new WordCounterService();\r\n    const wordCounterController = new WordNodeCounterController(wordCounter);\r\n    const nodeController = new NodeController();\r\n    const functionController = new FunctionController();\r\n\r\n    // Add to a list of disposables to be disposed when this extension is deactivated.\r\n    disposables.push(wordCounter, wordCounterController, nodeController, functionController);\r\n\r\n    // Show mapping progress, runs in parallel.\r\n    (async () => {\r\n        try {\r\n          await Promise.all([\r\n            window.withProgress({ location: ProgressLocation.Window, title: \"Mapping knots and stitches...\" }, generateNodeMaps),\r\n            window.withProgress({ location: ProgressLocation.Window, title: \"Mapping function declarations...\" }, generateFunctionMaps)\r\n          ]);\r\n        } catch (err) {\r\n          console.error(\"Error while mapping:\", err);\r\n        }\r\n    })();\r\n    \r\n    // Register language features and push to disposables.\r\n    disposables.push(\r\n        languages.registerCompletionItemProvider(INK, new DivertCompletionProvider(), '>', '-', ' '),\r\n        languages.registerDefinitionProvider(INK, new InkDivertDefinitionProvider()),\r\n        languages.registerDefinitionProvider(INK, new InkFunctionDefinitionProvider()),\r\n        languages.registerDefinitionProvider(INK, new InkVariableDefinitionProvider())\r\n    );\r\n\r\n    // Register everything for disposal.\r\n    context.subscriptions.push(...disposables);\r\n}","import { CompletionItem, CompletionItemKind, Location, Position, Uri, workspace } from \"vscode\";\r\nimport { AbstractMapController } from \"./AbstractMapController\";\r\nimport { NodeMap } from \"../models/NodeMap\";\r\nimport { StitchNode } from \"../models/StitchNode\";\r\nimport { DivertTarget } from \"../models/DivertTarget\";\r\n\r\n// Global node map store\r\nconst nodeMaps: Record<string, NodeMap> = {};\r\n\r\n// These are always available as completion targets, ignore scope\r\nconst PERMANENT_DIVERTS: CompletionItem[] = [\r\n    new CompletionItem(\"END\", CompletionItemKind.Keyword),\r\n    new CompletionItem(\"DONE\", CompletionItemKind.Keyword),\r\n    new CompletionItem(\"->\", CompletionItemKind.Keyword)\r\n];\r\n\r\n// Controller hooked to workspace change events\r\nexport class NodeController extends AbstractMapController<NodeMap> {\r\n    constructor() {\r\n        super(\r\n            nodeMaps,\r\n            /[\\n*+\\(\\)\\-=\\[]/, // Trigger characters\r\n            NodeMap.nodeMapFromDocument\r\n        );\r\n    }\r\n}\r\n\r\n// Loads all .ink files in the workspace and populates the nodeMaps\r\nexport async function generateNodeMaps(): Promise<void> {\r\n    try {\r\n        const allFiles = await workspace.findFiles(\"**/*.ink\");\r\n        const uniqueFiles = Array.from(new Map(allFiles.map(f => [f.fsPath, f])).values());\r\n\r\n        const maps = await Promise.all(uniqueFiles.map(f => NodeMap.loadFromFilePath(f.fsPath)));\r\n        maps.forEach(map => {\r\n            nodeMaps[map.filePath] = map;\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error generating node maps:\", err);\r\n    }\r\n}\r\n\r\n// Converts divert targets into VSCode CompletionItems\r\nexport function getDivertCompletionTargets(filePath: string, line: number): CompletionItem[] {\r\n    return [\r\n        ...getDivertsInScope(filePath, line)\r\n            .filter(target => target.name)\r\n            .map(target => target.toCompletionItem()),\r\n        ...PERMANENT_DIVERTS\r\n    ];\r\n}\r\n\r\n// Returns the StitchNode that contains the given line\r\nfunction stitchFor(filePath: string, line: number): StitchNode | null {\r\n    const map = nodeMaps[filePath];\r\n    if (!map) return null;\r\n\r\n    const knot = map.knots.find(k => k.startLine <= line && k.endLine > line);\r\n    if (!knot) return null;\r\n\r\n    return knot.stitches.find(s => s.startLine <= line && s.endLine > line) ?? null;\r\n}\r\n\r\n// Recursively gathers all included file paths starting from filePath\r\nfunction getIncludeScope(filePath: string, visited: Set<string> = new Set()): string[] {\r\n    if (visited.has(filePath)) return Array.from(visited);\r\n    visited.add(filePath);\r\n\r\n    const map = nodeMaps[filePath];\r\n    if (!map) return Array.from(visited);\r\n\r\n    for (const include of map.includes) {\r\n        getIncludeScope(include, visited);\r\n    }\r\n\r\n    return Array.from(visited);\r\n}\r\n\r\n// Gets all divert targets in scope (local + includes + current stitch/labels)\r\nfunction getDivertsInScope(filePath: string, line: number): DivertTarget[] {\r\n    const map = nodeMaps[filePath];\r\n    if (!map) return [];\r\n\r\n    const scopeFiles = getIncludeScope(filePath);\r\n    const targets: DivertTarget[] = scopeFiles.flatMap(path => nodeMaps[path]?.knots ?? []);\r\n\r\n    const stitch = stitchFor(filePath, line);\r\n    if (stitch) {\r\n        targets.push(...stitch.parentKnot.stitches);\r\n        targets.push(...stitch.labels);\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n// Gets a Location for a divert target by name in scope\r\nexport function getDefinitionByNameAndScope(name: string, filePath: string, line: number): Location {\r\n    let target = getDivertsInScope(filePath, line).find(t => t.name === name);\r\n\r\n    if (!target) {\r\n        for (const key in nodeMaps) {\r\n            target = getDivertsInScope(key, line).find(t => t.name === name);\r\n            if (target) break;\r\n        }\r\n    }\r\n\r\n    if (!target) {\r\n        throw new Error(`No divert target named '${name}' found in scope at ${filePath}:${line}`);\r\n    }\r\n\r\n    return new Location(Uri.file(target.parentFile.filePath), new Position(target.line, 0));\r\n}  ","import { Disposable, TextDocumentChangeEvent, TextDocument, workspace } from \"vscode\";\r\n\r\nexport abstract class AbstractMapController<TMap> {\r\n    private readonly _disposable: Disposable;\r\n\r\n    protected constructor\r\n        (\r\n            private readonly mapStore: Record<string, TMap>,\r\n            private readonly matchTrigger: RegExp,\r\n            private readonly mapFromDocument: (doc: TextDocument) => TMap\r\n        ) {\r\n        const subscriptions: Disposable[] = [\r\n            workspace.onDidChangeTextDocument(this._handleTextChange, this)\r\n        ];\r\n\r\n        this._disposable = Disposable.from(...subscriptions);\r\n    }\r\n\r\n    private _handleTextChange({ contentChanges, document }: TextDocumentChangeEvent) {\r\n        if (!contentChanges.some(change => this.matchTrigger.test(change.text))) return;\r\n        const { fsPath } = document.uri;\r\n        this.mapStore[fsPath] = this.mapFromDocument(document);\r\n    }\r\n\r\n    public dispose() {\r\n        this._disposable.dispose();\r\n    }\r\n}\r\n\r\nexport async function generateMapsFromFiles<T>(\r\n    loader: (fsPath: string) => Promise<T>\r\n): Promise<Record<string, T>> {\r\n    const allFiles = await workspace.findFiles(\"**/*.ink\");\r\n    const uniqueFiles = Array.from(new Map(allFiles.map(f => [f.fsPath, f])).values());\r\n\r\n    const maps = await Promise.all(uniqueFiles.map(file => loader(file.fsPath)));\r\n    const result: Record<string, T> = {};\r\n    for (const map of maps) {\r\n        const key = (map as any).filePath;\r\n        result[key] = map;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function findDefinition<T extends { name: string }>(\r\n    name: string,\r\n    filePath: string,\r\n    maps: Record<string, any>,\r\n    extractor: (map: any) => T[]\r\n): T | null {\r\n    const local = maps[filePath];\r\n    if (local) {\r\n        const found = extractor(local).find(def => def.name === name);\r\n        if (found) return found;\r\n    }\r\n\r\n    for (const key in maps) {\r\n        if (key === filePath) continue;\r\n        const found = extractor(maps[key]).find(def => def.name === name);\r\n        if (found) return found;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n\r\n","import path from \"path\";\r\nimport fs from \"fs\";\r\nimport { KnotNode } from \"./KnotNode\";\r\nimport { TextDocument } from \"vscode\";\r\n\r\nexport class NodeMap {\r\n    public readonly knots: KnotNode[];\r\n    public readonly includes: string[];\r\n\r\n    private constructor(public readonly filePath: string, fileText: string) {\r\n        const lines = fileText.split(\"\\n\");\r\n\r\n        this.knots = this._parseKnots(lines);\r\n        this.includes = this._parseIncludes(lines);\r\n\r\n        console.log(\"Knots found:\", this.knots.map(k => k.name));\r\n    }\r\n\r\n    private _parseKnots(lines: string[]): KnotNode[] {\r\n        const knots: KnotNode[] = [];\r\n\r\n        const headerRegex = /^\\s*===(\\s*function)?\\s*(\\w+)\\s*===/;\r\n\r\n        let currentLines: string[] = [];\r\n        let lastStart = 0;\r\n        let lastName: string | null = null;\r\n        let isFunction = false;\r\n\r\n        // Pushes the current knot to the list of knots\r\n        const pushKnot = (end: number, isFinal = false) => {\r\n            if (lastName !== null) {\r\n                const content = currentLines.join(\"\\n\");\r\n                knots.push(new KnotNode(lastName, lastStart, end, this, content, isFunction, isFinal));\r\n            }\r\n        };\r\n\r\n        // Iterate over each line in the file, parsing knot headers\r\n        lines.forEach((line, index) => {\r\n            const match = headerRegex.exec(line);\r\n\r\n            if (match) {\r\n                pushKnot(index);\r\n                lastName = match[2];\r\n                isFunction = !!match[1];\r\n                lastStart = index;\r\n                currentLines = [line];\r\n            } else {\r\n                currentLines.push(line);\r\n                if (index === lines.length - 1) {\r\n                    pushKnot(index + 1, true);\r\n                }\r\n            }\r\n        });\r\n\r\n        return knots;\r\n    }\r\n\r\n    private _parseIncludes(lines: string[]): string[] {\r\n        const includeRegex = /^\\s*INCLUDE\\s+(\\w+\\.ink)/;\r\n\r\n        return lines\r\n            .map(line => includeRegex.exec(line))\r\n            .filter(Boolean)\r\n            .map(match => {\r\n                const filename = match![1];\r\n                return path.resolve(path.dirname(this.filePath), filename);\r\n            });\r\n    }\r\n\r\n    public static async loadFromFilePath(filePath: string): Promise<NodeMap> {\r\n        try {\r\n            const data = await fs.promises.readFile(filePath, \"utf8\");\r\n            return new NodeMap(filePath, data);\r\n        } catch (err) {\r\n            console.error(\"Error opening file:\", err);\r\n            return new NodeMap(filePath, \"\");\r\n        }\r\n    }\r\n\r\n    public static nodeMapFromDocument(document: TextDocument): NodeMap {\r\n        return new NodeMap(document.uri.fsPath, document.getText());\r\n    }\r\n}","import { CompletionItem, CompletionItemKind } from \"vscode\";\r\nimport { DivertTarget } from \"./DivertTarget\";\r\nimport { StitchNode } from \"./StitchNode\";\r\nimport { NodeMap } from \"./NodeMap\";\r\n\r\nexport class KnotNode extends DivertTarget {\r\n    public readonly stitches: StitchNode[];\r\n\r\n    constructor\r\n    (\r\n        public readonly name: string | null,\r\n        public readonly startLine: number,\r\n        public readonly endLine: number,\r\n        private readonly _parentFile: NodeMap,\r\n        textContent: string,\r\n        private readonly isFunction: boolean = false,\r\n        private readonly lastLine: boolean = false\r\n    ) \r\n    {\r\n        super(name);\r\n        this.stitches = this._parseStitches(textContent);\r\n    }\r\n\r\n    public get line(): number\r\n    {\r\n        return this.startLine;\r\n    }\r\n\r\n    public get parentFile(): NodeMap \r\n    {\r\n        return this._parentFile;\r\n    }\r\n\r\n    public toCompletionItem(): CompletionItem \r\n    {\r\n        const itemKind = this.isFunction ? CompletionItemKind.Function : CompletionItemKind.Reference;\r\n        return new CompletionItem(this.name ?? \"\", itemKind);\r\n    }\r\n\r\n    private _parseStitches(content: string): StitchNode[] \r\n    {\r\n        // split content into lines\r\n        const lines = content.split(\"\\n\");\r\n        const stitches: StitchNode[] = [];\r\n      \r\n        const stitchRegex = /^\\s*=\\s*(\\w+)/;\r\n      \r\n        // track current stitch\r\n        let currentName: string | null = null;\r\n        let currentStart = 0;\r\n        let currentLines: string[] = [];\r\n      \r\n        // push current stitch to stitches array\r\n        const pushStitch = (end: number, isFinal: boolean = false) => {\r\n          if (!currentName) return;\r\n          const text = currentLines.join(\"\\n\");\r\n          stitches.push(new StitchNode(currentName, currentStart, end, this, text, isFinal));\r\n        };\r\n      \r\n        // iterate through lines and parse stitches\r\n        for (let i = 0; i < lines.length; i++) {\r\n          const line = lines[i];\r\n          const match = stitchRegex.exec(line);\r\n      \r\n          if (match) {\r\n            // push previous before starting new\r\n            if (currentLines.length > 0) {\r\n              pushStitch(i);\r\n            }\r\n      \r\n            currentName = match[1];\r\n            currentStart = i;\r\n            currentLines = [line];\r\n          } else {\r\n            currentLines.push(line);\r\n          }\r\n      \r\n          // last line handling\r\n          const isLastLine = i === lines.length - 1;\r\n          if (isLastLine && currentName) {\r\n            pushStitch(i + 1, this.lastLine);\r\n          }\r\n        }\r\n      \r\n        return stitches;\r\n    }      \r\n}\r\n","import { CompletionItem, CompletionItemKind } from \"vscode\";\r\nimport { NodeMap } from \"./NodeMap\";\r\n\r\nexport abstract class DivertTarget {\r\n    constructor(public readonly name: string | null) {}\r\n\r\n    get line(): number \r\n    {\r\n        throw new Error(\"Subclasses must implement 'line' getter\");\r\n    }\r\n\r\n    get parentFile(): NodeMap \r\n    {\r\n        throw new Error(\"Subclasses must implement 'parentFile' getter\");\r\n    }\r\n\r\n    toCompletionItem(): CompletionItem \r\n    {\r\n        return new CompletionItem(this.name ?? \"\", CompletionItemKind.Reference);\r\n    }\r\n}","import { DivertTarget } from \"./DivertTarget\";\r\nimport { NodeMap } from \"./NodeMap\";\r\nimport { StitchNode } from \"./StitchNode\";\r\n\r\nexport class LabelNode extends DivertTarget {\r\n    constructor\r\n    (\r\n        public readonly name: string, \r\n        private readonly _line: number, \r\n        public readonly parentStitch: StitchNode\r\n    ) \r\n    {\r\n        super(name);\r\n    }\r\n\r\n    get line(): number \r\n    {\r\n        return this._line + this.parentStitch.startLine;\r\n    }\r\n\r\n    get parentFile(): NodeMap \r\n    {\r\n        return this.parentStitch.parentKnot.parentFile;\r\n    }\r\n}","import { DivertTarget } from \"./DivertTarget\";\r\nimport { KnotNode } from \"./KnotNode\";\r\nimport { LabelNode } from \"./LabelNode\";\r\n\r\nexport class StitchNode extends DivertTarget {\r\n    public readonly labels: LabelNode[];\r\n\r\n    constructor(\r\n        public readonly name: string,\r\n        private readonly _relativeStart: number,\r\n        private readonly _relativeEnd: number,\r\n        public readonly parentKnot: KnotNode,\r\n        textContent: string,\r\n        private readonly lastLine: boolean = false\r\n    ) {\r\n        super(name);\r\n        this.labels = this._extractLabels(textContent);\r\n    }\r\n\r\n    get line(): number {\r\n        return this.startLine;\r\n    }\r\n\r\n    get startLine(): number {\r\n        return this.parentKnot.startLine + this._relativeStart;\r\n    }\r\n\r\n    get endLine(): number {\r\n        return this.parentKnot.startLine + this._relativeEnd + (this.lastLine ? 1 : 0);\r\n    }\r\n\r\n    get parentFile() {\r\n        return this.parentKnot.parentFile;\r\n    }\r\n\r\n    private _extractLabels(text: string): LabelNode[] {\r\n        const labelRegex = /^\\s*[-*+]\\s*\\((\\w+)\\)/;\r\n        const lines = text.split(\"\\n\");\r\n        const labels: LabelNode[] = [];\r\n\r\n        // iterate through each line of the stitch and extract labels\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const match = labelRegex.exec(lines[i]);\r\n            if (match) {\r\n                labels.push(new LabelNode(match[1], i, this));\r\n            }\r\n        }\r\n\r\n        return labels;\r\n    }\r\n}","import { DefinitionProvider,Location,TextDocument, Position, ProviderResult} from \"vscode\";\r\nimport { getDefinitionByNameAndScope } from \"../controllers/NodeController\";\r\n\r\nexport class InkDivertDefinitionProvider implements DefinitionProvider \r\n{\r\n    private static readonly divertRegex = /->\\s*([\\w.]+)/;\r\n\r\n    public provideDefinition(document: TextDocument, position: Position): ProviderResult<Location> {\r\n      // Get the line of text at the cursor and match it against the divert regex.\r\n      const lineText = document.lineAt(position.line).text;\r\n      const cursorPos = position.character;\r\n\r\n      const match = InkDivertDefinitionProvider.divertRegex.exec(lineText.slice(0, cursorPos) + lineText.slice(cursorPos));\r\n      if (!match) return;\r\n\r\n      // Get the target of the divert and return its definition.\r\n      const [target] = match[1].split(\".\");\r\n      return getDefinitionByNameAndScope(target, document.uri.fsPath, position.line);\r\n    }\r\n}\r\n","import { DefinitionProvider, Location, TextDocument, Position, ProviderResult, Uri} from \"vscode\";\r\nimport { getFunctionDefinitionByName } from \"../controllers/FunctionController\";\r\n\r\nexport class InkFunctionDefinitionProvider implements DefinitionProvider {\r\n    private static readonly functionCallRegex = /\\b([\\w]+)\\s*/;\r\n\r\n    public provideDefinition(document: TextDocument, position: Position): ProviderResult<Location> \r\n    {\r\n      const lineText = document.lineAt(position.line).text;\r\n\r\n      // only care about logic lines, i.e lines that start with a tilde\r\n      if (!lineText.trimStart().startsWith(\"~\")) return;\r\n\r\n      // match to see if the line contains a function call\r\n      const match = InkFunctionDefinitionProvider.functionCallRegex.exec(lineText);\r\n      if (!match) return;\r\n\r\n      // get the name of the function and find its definition\r\n      const functionName = match[1];\r\n      const result = getFunctionDefinitionByName(functionName, document.uri.fsPath);\r\n      if (!result) return;\r\n\r\n      // return the location of the function definition\r\n      return new Location(Uri.file(result.filePath), new Position(result.line, 0));\r\n    }\r\n}\r\n\r\n","import { TextDocument, workspace } from \"vscode\";\r\nimport * as fs from \"fs\";\r\nimport { FunctionDefinition } from \"./definitions/FunctionDefinition\";\r\nimport { VariableDefinition } from \"./definitions/VariableDefinition\";\r\n\r\nexport class FunctionMap {\r\n    public readonly filePath: string;\r\n    public readonly functions: FunctionDefinition[] = [];\r\n    public readonly variables: VariableDefinition[] = [];\r\n\r\n    private constructor(filePath: string, functions: FunctionDefinition[], variables: VariableDefinition[]) {\r\n        this.filePath = filePath;\r\n        this.functions = functions;\r\n        this.variables = variables;\r\n    }\r\n\r\n    public static fromDocument(doc: TextDocument): FunctionMap {\r\n        const filePath = doc.uri.fsPath;\r\n        const text = doc.getText();\r\n        const lines = text.split(/\\r?\\n/);\r\n\r\n        const functions: FunctionDefinition[] = [];\r\n        const variables: VariableDefinition[] = [];\r\n\r\n        lines.forEach((line, i) => {\r\n            // EXTERNAL function\r\n            const externalMatch = line.match(/^\\s*EXTERNAL\\s+(\\w+)\\s*\\(/i);\r\n            if (externalMatch) {\r\n                functions.push({\r\n                    name: externalMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"EXTERNAL\"\r\n                });\r\n            }\r\n\r\n            // === function style\r\n            const functionMatch = line.match(/^\\s*===\\s*function\\s+(\\w+)\\s*/i);\r\n            if (functionMatch) {\r\n                functions.push({\r\n                    name: functionMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"FUNCTION\"\r\n                });\r\n            }\r\n\r\n            // VAR declaration\r\n            const varMatch = line.match(/^\\s*VAR\\s+(\\w+)\\s*=/i);\r\n            if (varMatch) {\r\n                variables.push({\r\n                    name: varMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"VAR\"\r\n                });\r\n            }\r\n\r\n            // TEMP declaration\r\n            const tempMatch = line.match(/^\\s*~\\s*temp\\s+(\\w+)\\s*=/i);\r\n            if (tempMatch) {\r\n                variables.push({\r\n                    name: tempMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"TEMP\"\r\n                });\r\n            }\r\n        });\r\n\r\n        return new FunctionMap(filePath, functions, variables);\r\n    }\r\n\r\n    public static async from(filePath: string): Promise<FunctionMap> {\r\n        const content = fs.readFileSync(filePath, \"utf8\");\r\n        const lines = content.split(/\\r?\\n/);\r\n\r\n        const functions: FunctionDefinition[] = [];\r\n        const variables: VariableDefinition[] = [];\r\n\r\n        lines.forEach((line, i) => {\r\n            const externalMatch = line.match(/^\\s*EXTERNAL\\s+(\\w+)\\s*\\(/i);\r\n            if (externalMatch) {\r\n                functions.push({\r\n                    name: externalMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"EXTERNAL\"\r\n                });\r\n            }\r\n\r\n            const functionMatch = line.match(/^\\s*===\\s*function\\s+(\\w+)\\s*/i);\r\n            if (functionMatch) {\r\n                functions.push({\r\n                    name: functionMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"FUNCTION\"\r\n                });\r\n            }\r\n\r\n            const varMatch = line.match(/^\\s*VAR\\s+(\\w+)\\s*=/i);\r\n            if (varMatch) {\r\n                variables.push({\r\n                    name: varMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"VAR\"\r\n                });\r\n            }\r\n\r\n            const tempMatch = line.match(/^\\s*~\\s*temp\\s+(\\w+)\\s*=/i);\r\n            if (tempMatch) {\r\n                variables.push({\r\n                    name: tempMatch[1],\r\n                    line: i,\r\n                    filePath,\r\n                    type: \"TEMP\"\r\n                });\r\n            }\r\n        });\r\n\r\n        return new FunctionMap(filePath, functions, variables);\r\n    }\r\n}\r\n","import { AbstractMapController, findDefinition, generateMapsFromFiles } from \"./AbstractMapController\";\r\nimport { FunctionMap } from \"../models/FunctionMap\";\r\nimport { FunctionDefinition } from \"../models/definitions/FunctionDefinition\";\r\nimport { VariableDefinition } from \"../models/definitions/VariableDefinition\";\r\n\r\nconst functionMaps: Record<string, FunctionMap> = {};\r\n\r\nexport class FunctionController extends AbstractMapController<FunctionMap> {\r\n  constructor() {\r\n    super(functionMaps, /[\\n=]|EXTERNAL/, FunctionMap.fromDocument);\r\n  }\r\n}\r\n\r\nexport async function generateFunctionMaps(): Promise<void> {\r\n  Object.assign(functionMaps, await generateMapsFromFiles(FunctionMap.from));\r\n}\r\n\r\nexport function getFunctionDefinitionByName(name: string, filePath: string): FunctionDefinition | null {\r\n  return findDefinition(name, filePath, functionMaps, m => m.functions);\r\n}\r\n\r\nexport function getVariableDefinitionByName(name: string, filePath: string): VariableDefinition | null {\r\n  return findDefinition(name, filePath, functionMaps, m => m.variables);\r\n}\r\n","import { CompletionItemProvider, TextDocument, Position, CancellationToken, CompletionItem, Range, CompletionItemKind, workspace } from \"vscode\";\r\nimport { getDivertCompletionTargets } from \"../controllers/NodeController\";\r\n\r\nexport class DivertCompletionProvider implements CompletionItemProvider \r\n{\r\n    private static readonly divertPattern = /(->|<-) ?$/;\r\n    private static readonly doubleArrowPattern = /-> ?-> ?$/;\r\n\r\n    public provideCompletionItems (document: TextDocument, position: Position) : CompletionItem[] {\r\n        // Make sure we are at the end of a valid divert arrow.\r\n        // Ignore a > at the start of a line.\r\n        const lineText = document.getText(new Range(\r\n            position.with(position.line, 0),\r\n            position\r\n        ));\r\n\r\n        if (!DivertCompletionProvider.divertPattern.test(lineText)) return;\r\n        if (DivertCompletionProvider.doubleArrowPattern.test(lineText)) return;\r\n        \r\n        return getDivertCompletionTargets(document.uri.fsPath, position.line);\r\n    }\r\n}","import { DefinitionProvider, Location, Position, ProviderResult, TextDocument, Uri} from \"vscode\";\r\nimport { getVariableDefinitionByName } from \"../controllers/FunctionController\";\r\n\r\nexport class InkVariableDefinitionProvider implements DefinitionProvider {\r\n    public provideDefinition(document: TextDocument, position: Position): ProviderResult<Location>\r\n    {\r\n        const wordRange = document.getWordRangeAtPosition(position);\r\n        if (!wordRange) return;\r\n\r\n        const variableName = document.getText(wordRange);\r\n        if (!variableName) return;\r\n\r\n        const result = getVariableDefinitionByName(variableName, document.uri.fsPath);\r\n        if (!result) return;\r\n\r\n        return new Location(Uri.file(result.filePath), new Position(result.line, 0));\r\n    }\r\n}\r\n","import { Disposable, window } from \"vscode\";\r\nimport { WordCounterService } from \"./WordCounterService\";\r\n\r\nexport class WordNodeCounterController \r\n{\r\n    private _disposable: Disposable;\r\n\r\n    constructor (private readonly wordCounter: WordCounterService) \r\n    {\r\n        this.wordCounter.updateWordCount();\r\n\r\n        const subscriptions: Disposable[] = [\r\n            window.onDidChangeTextEditorSelection(this._onEvent, this),\r\n            window.onDidChangeActiveTextEditor(this._onEvent, this)\r\n        ];\r\n\r\n        this._disposable = Disposable.from(...subscriptions);\r\n    }\r\n\r\n    private _onEvent() \r\n    {\r\n        this.wordCounter.updateWordCount();\r\n    }\r\n\r\n    public dispose() \r\n    {\r\n        this._disposable.dispose();\r\n    }\r\n}","'use strict';\r\n\r\nimport { window, StatusBarAlignment, StatusBarItem } from \"vscode\";\r\n\r\n/* Provides word count functionality. Mostly adapted from the example\r\n    word counter extension.\r\n*/\r\nexport class WordCounterService {\r\n    private _statusBarItem: StatusBarItem | undefined;\r\n\r\n    private plural (n: number, word: string) : string \r\n    {\r\n        return `${n} ${word}${n === 1 ? '' : 's'}`;\r\n    }\r\n\r\n    public updateWordCount() \r\n    {\r\n        // If the editor is not active, hide the status bar item.\r\n        const editor = window.activeTextEditor;\r\n        if (!editor) \r\n        {\r\n            this._statusBarItem.hide();\r\n            return;\r\n        }\r\n\r\n        // If the document is not an Ink document, hide the status bar item.\r\n        const doc = editor.document;\r\n        if (doc.languageId !== \"ink\") \r\n        {\r\n            this._statusBarItem.hide();\r\n            return;\r\n        }\r\n\r\n        // Since the status bar item is not yet created, create it, since we are in an Ink document.\r\n        if (!this._statusBarItem)\r\n        {\r\n            this._statusBarItem = window.createStatusBarItem(StatusBarAlignment.Left);\r\n        }\r\n\r\n        const docContent = doc.getText();\r\n        const wordCount = this._getWordCount(docContent);\r\n        const nodeCount = this._getNodeCount(docContent);\r\n\r\n        // Update the status bar, finally.\r\n        this._statusBarItem.text = `$(pencil) ${this.plural(wordCount, \"word\")} in ${this.plural(nodeCount, \"node\")}`;\r\n        this._statusBarItem.show();\r\n    }\r\n\r\n    private _getWordCount(content: string): number \r\n    {\r\n        const lines = content.split(\"\\n\");\r\n      \r\n        const cleaned = this._stripMultilineBlocks(lines)\r\n        .map(line => this._stripCommentsAndBlocks(line))\r\n        .filter(line => this._isNarrativeLine(line));\r\n      \r\n        const text = cleaned.join(\" \");\r\n        return text\r\n          .split(/\\s+/)\r\n          .filter(word => /\\w/.test(word)).length;\r\n    }\r\n\r\n    private _stripCommentsAndBlocks(line: string): string \r\n    {\r\n        // remove single-line comments\r\n        line = line.replace(/\\/\\/.*$/, \"\");\r\n      \r\n        // remove inline logic blocks like { some logic }\r\n        line = line.replace(/\\{.*?\\}/g, \"\");\r\n      \r\n        // remove inline multi-line comments\r\n        line = line.replace(/\\/\\*.*?\\*\\//g, \"\");\r\n      \r\n        return line.trim();\r\n    }\r\n\r\n    private _isNarrativeLine(line: string): boolean \r\n    {\r\n        if (line.trim().length === 0) return false;\r\n        if (/^\\s*(~|=|VAR|EXTERNAL|INCLUDE)/.test(line)) return false;\r\n        return true;\r\n    }\r\n\r\n    private _stripMultilineBlocks(lines: string[]): string[] \r\n    {\r\n        let inBlock = false;\r\n        let inComment = false;\r\n        const result: string[] = [];\r\n      \r\n        for (let line of lines) {\r\n          if (inBlock) {\r\n            if (line.includes(\"}\")) {\r\n              inBlock = false;\r\n              line = line.split(\"}\")[1] || \"\";\r\n            } else continue;\r\n          }\r\n      \r\n          if (inComment) {\r\n            if (line.includes(\"*/\")) {\r\n              inComment = false;\r\n              line = line.split(\"*/\")[1] || \"\";\r\n            } else continue;\r\n          }\r\n      \r\n          if (line.includes(\"/*\") && !line.includes(\"*/\")) {\r\n            inComment = true;\r\n            continue;\r\n          }\r\n      \r\n          if (line.includes(\"{\") && !line.includes(\"}\")) {\r\n            inBlock = true;\r\n            continue;\r\n          }\r\n      \r\n          result.push(line);\r\n        }\r\n      \r\n        return result;\r\n    }\r\n\r\n    public _getNodeCount (docContent: string): number \r\n    {\r\n        return docContent.split(\"\\n\").filter(line => line.match(/^\\s*=/)).length;\r\n    }\r\n\r\n    public dispose() \r\n    {\r\n        this._statusBarItem.dispose();\r\n    }\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,IAAAA,kBAAsF;;;ACHtF,IAAAC,iBAAuF;;;ACAvF,oBAA6E;AAEtE,IAAe,wBAAf,MAA2C;AAAA,EAGpC,YAEe,UACA,cACA,iBACnB;AAHmB;AACA;AACA;AAErB,UAAM,gBAA8B;AAAA,MAChC,wBAAU,wBAAwB,KAAK,mBAAmB,IAAI;AAAA,IAClE;AAEA,SAAK,cAAc,yBAAW,KAAK,GAAG,aAAa;AAAA,EACvD;AAAA,EAEQ,kBAAkB,EAAE,gBAAgB,SAAS,GAA4B;AAC7E,QAAI,CAAC,eAAe,KAAK,YAAU,KAAK,aAAa,KAAK,OAAO,IAAI,CAAC,EAAG;AACzE,UAAM,EAAE,OAAO,IAAI,SAAS;AAC5B,SAAK,SAAS,MAAM,IAAI,KAAK,gBAAgB,QAAQ;AAAA,EACzD;AAAA,EAEO,UAAU;AACb,SAAK,YAAY,QAAQ;AAAA,EAC7B;AACJ;AAEA,eAAsB,sBAClB,QAC0B;AAC1B,QAAM,WAAW,MAAM,wBAAU,UAAU,UAAU;AACrD,QAAM,cAAc,MAAM,KAAK,IAAI,IAAI,SAAS,IAAI,OAAK,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;AAEjF,QAAM,OAAO,MAAM,QAAQ,IAAI,YAAY,IAAI,UAAQ,OAAO,KAAK,MAAM,CAAC,CAAC;AAC3E,QAAM,SAA4B,CAAC;AACnC,aAAW,OAAO,MAAM;AACpB,UAAM,MAAO,IAAY;AACzB,WAAO,GAAG,IAAI;AAAA,EAClB;AACA,SAAO;AACX;AAEO,SAAS,eACZ,MACA,UACA,MACA,WACQ;AACR,QAAM,QAAQ,KAAK,QAAQ;AAC3B,MAAI,OAAO;AACP,UAAM,QAAQ,UAAU,KAAK,EAAE,KAAK,SAAO,IAAI,SAAS,IAAI;AAC5D,QAAI,MAAO,QAAO;AAAA,EACtB;AAEA,aAAW,OAAO,MAAM;AACpB,QAAI,QAAQ,SAAU;AACtB,UAAM,QAAQ,UAAU,KAAK,GAAG,CAAC,EAAE,KAAK,SAAO,IAAI,SAAS,IAAI;AAChE,QAAI,MAAO,QAAO;AAAA,EACtB;AAEA,SAAO;AACX;;;AC/DA,kBAAiB;AACjB,gBAAe;;;ACDf,IAAAC,iBAAmD;;;ACAnD,IAAAC,iBAAmD;AAG5C,IAAe,eAAf,MAA4B;AAAA,EAC/B,YAA4B,MAAqB;AAArB;AAAA,EAAsB;AAAA,EAElD,IAAI,OACJ;AACI,UAAM,IAAI,MAAM,yCAAyC;AAAA,EAC7D;AAAA,EAEA,IAAI,aACJ;AACI,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACnE;AAAA,EAEA,mBACA;AACI,WAAO,IAAI,8BAAe,KAAK,QAAQ,IAAI,kCAAmB,SAAS;AAAA,EAC3E;AACJ;;;AChBO,IAAM,YAAN,cAAwB,aAAa;AAAA,EACxC,YAEoB,MACC,OACD,cAEpB;AACI,UAAM,IAAI;AALM;AACC;AACD;AAAA,EAIpB;AAAA,EAEA,IAAI,OACJ;AACI,WAAO,KAAK,QAAQ,KAAK,aAAa;AAAA,EAC1C;AAAA,EAEA,IAAI,aACJ;AACI,WAAO,KAAK,aAAa,WAAW;AAAA,EACxC;AACJ;;;ACpBO,IAAM,aAAN,cAAyB,aAAa;AAAA,EAGzC,YACoB,MACC,gBACA,cACD,YAChB,aACiB,WAAoB,OACvC;AACE,UAAM,IAAI;AAPM;AACC;AACA;AACD;AAEC;AAGjB,SAAK,SAAS,KAAK,eAAe,WAAW;AAAA,EACjD;AAAA,EAEA,IAAI,OAAe;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,YAAoB;AACpB,WAAO,KAAK,WAAW,YAAY,KAAK;AAAA,EAC5C;AAAA,EAEA,IAAI,UAAkB;AAClB,WAAO,KAAK,WAAW,YAAY,KAAK,gBAAgB,KAAK,WAAW,IAAI;AAAA,EAChF;AAAA,EAEA,IAAI,aAAa;AACb,WAAO,KAAK,WAAW;AAAA,EAC3B;AAAA,EAEQ,eAAe,MAA2B;AAC9C,UAAM,aAAa;AACnB,UAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,UAAM,SAAsB,CAAC;AAG7B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,QAAQ,WAAW,KAAK,MAAM,CAAC,CAAC;AACtC,UAAI,OAAO;AACP,eAAO,KAAK,IAAI,UAAU,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC;AAAA,MAChD;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AACJ;;;AH7CO,IAAM,WAAN,cAAuB,aAAa;AAAA,EAGvC,YAEoB,MACA,WACA,SACC,aACjB,aACiB,aAAsB,OACtB,WAAoB,OAEzC;AACI,UAAM,IAAI;AATM;AACA;AACA;AACC;AAEA;AACA;AAIjB,SAAK,WAAW,KAAK,eAAe,WAAW;AAAA,EACnD;AAAA,EAEA,IAAW,OACX;AACI,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAW,aACX;AACI,WAAO,KAAK;AAAA,EAChB;AAAA,EAEO,mBACP;AACI,UAAM,WAAW,KAAK,aAAa,kCAAmB,WAAW,kCAAmB;AACpF,WAAO,IAAI,8BAAe,KAAK,QAAQ,IAAI,QAAQ;AAAA,EACvD;AAAA,EAEQ,eAAe,SACvB;AAEI,UAAM,QAAQ,QAAQ,MAAM,IAAI;AAChC,UAAM,WAAyB,CAAC;AAEhC,UAAM,cAAc;AAGpB,QAAI,cAA6B;AACjC,QAAI,eAAe;AACnB,QAAI,eAAyB,CAAC;AAG9B,UAAM,aAAa,CAAC,KAAa,UAAmB,UAAU;AAC5D,UAAI,CAAC,YAAa;AAClB,YAAM,OAAO,aAAa,KAAK,IAAI;AACnC,eAAS,KAAK,IAAI,WAAW,aAAa,cAAc,KAAK,MAAM,MAAM,OAAO,CAAC;AAAA,IACnF;AAGA,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,QAAQ,YAAY,KAAK,IAAI;AAEnC,UAAI,OAAO;AAET,YAAI,aAAa,SAAS,GAAG;AAC3B,qBAAW,CAAC;AAAA,QACd;AAEA,sBAAc,MAAM,CAAC;AACrB,uBAAe;AACf,uBAAe,CAAC,IAAI;AAAA,MACtB,OAAO;AACL,qBAAa,KAAK,IAAI;AAAA,MACxB;AAGA,YAAM,aAAa,MAAM,MAAM,SAAS;AACxC,UAAI,cAAc,aAAa;AAC7B,mBAAW,IAAI,GAAG,KAAK,QAAQ;AAAA,MACjC;AAAA,IACF;AAEA,WAAO;AAAA,EACX;AACJ;;;ADjFO,IAAM,UAAN,MAAM,SAAQ;AAAA,EAIT,YAA4B,UAAkB,UAAkB;AAApC;AAChC,UAAM,QAAQ,SAAS,MAAM,IAAI;AAEjC,SAAK,QAAQ,KAAK,YAAY,KAAK;AACnC,SAAK,WAAW,KAAK,eAAe,KAAK;AAEzC,YAAQ,IAAI,gBAAgB,KAAK,MAAM,IAAI,OAAK,EAAE,IAAI,CAAC;AAAA,EAC3D;AAAA,EAEQ,YAAY,OAA6B;AAC7C,UAAM,QAAoB,CAAC;AAE3B,UAAM,cAAc;AAEpB,QAAI,eAAyB,CAAC;AAC9B,QAAI,YAAY;AAChB,QAAI,WAA0B;AAC9B,QAAI,aAAa;AAGjB,UAAM,WAAW,CAAC,KAAa,UAAU,UAAU;AAC/C,UAAI,aAAa,MAAM;AACnB,cAAM,UAAU,aAAa,KAAK,IAAI;AACtC,cAAM,KAAK,IAAI,SAAS,UAAU,WAAW,KAAK,MAAM,SAAS,YAAY,OAAO,CAAC;AAAA,MACzF;AAAA,IACJ;AAGA,UAAM,QAAQ,CAAC,MAAM,UAAU;AAC3B,YAAM,QAAQ,YAAY,KAAK,IAAI;AAEnC,UAAI,OAAO;AACP,iBAAS,KAAK;AACd,mBAAW,MAAM,CAAC;AAClB,qBAAa,CAAC,CAAC,MAAM,CAAC;AACtB,oBAAY;AACZ,uBAAe,CAAC,IAAI;AAAA,MACxB,OAAO;AACH,qBAAa,KAAK,IAAI;AACtB,YAAI,UAAU,MAAM,SAAS,GAAG;AAC5B,mBAAS,QAAQ,GAAG,IAAI;AAAA,QAC5B;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEQ,eAAe,OAA2B;AAC9C,UAAM,eAAe;AAErB,WAAO,MACF,IAAI,UAAQ,aAAa,KAAK,IAAI,CAAC,EACnC,OAAO,OAAO,EACd,IAAI,WAAS;AACV,YAAM,WAAW,MAAO,CAAC;AACzB,aAAO,YAAAC,QAAK,QAAQ,YAAAA,QAAK,QAAQ,KAAK,QAAQ,GAAG,QAAQ;AAAA,IAC7D,CAAC;AAAA,EACT;AAAA,EAEA,aAAoB,iBAAiB,UAAoC;AACrE,QAAI;AACA,YAAM,OAAO,MAAM,UAAAC,QAAG,SAAS,SAAS,UAAU,MAAM;AACxD,aAAO,IAAI,SAAQ,UAAU,IAAI;AAAA,IACrC,SAAS,KAAK;AACV,cAAQ,MAAM,uBAAuB,GAAG;AACxC,aAAO,IAAI,SAAQ,UAAU,EAAE;AAAA,IACnC;AAAA,EACJ;AAAA,EAEA,OAAc,oBAAoB,UAAiC;AAC/D,WAAO,IAAI,SAAQ,SAAS,IAAI,QAAQ,SAAS,QAAQ,CAAC;AAAA,EAC9D;AACJ;;;AF3EA,IAAM,WAAoC,CAAC;AAG3C,IAAM,oBAAsC;AAAA,EACxC,IAAI,8BAAe,OAAO,kCAAmB,OAAO;AAAA,EACpD,IAAI,8BAAe,QAAQ,kCAAmB,OAAO;AAAA,EACrD,IAAI,8BAAe,MAAM,kCAAmB,OAAO;AACvD;AAGO,IAAM,iBAAN,cAA6B,sBAA+B;AAAA,EAC/D,cAAc;AACV;AAAA,MACI;AAAA,MACA;AAAA;AAAA,MACA,QAAQ;AAAA,IACZ;AAAA,EACJ;AACJ;AAGA,eAAsB,mBAAkC;AACpD,MAAI;AACA,UAAM,WAAW,MAAM,yBAAU,UAAU,UAAU;AACrD,UAAM,cAAc,MAAM,KAAK,IAAI,IAAI,SAAS,IAAI,OAAK,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;AAEjF,UAAM,OAAO,MAAM,QAAQ,IAAI,YAAY,IAAI,OAAK,QAAQ,iBAAiB,EAAE,MAAM,CAAC,CAAC;AACvF,SAAK,QAAQ,SAAO;AAChB,eAAS,IAAI,QAAQ,IAAI;AAAA,IAC7B,CAAC;AAAA,EACL,SAAS,KAAK;AACV,YAAQ,MAAM,+BAA+B,GAAG;AAAA,EACpD;AACJ;AAGO,SAAS,2BAA2B,UAAkB,MAAgC;AACzF,SAAO;AAAA,IACH,GAAG,kBAAkB,UAAU,IAAI,EAC9B,OAAO,YAAU,OAAO,IAAI,EAC5B,IAAI,YAAU,OAAO,iBAAiB,CAAC;AAAA,IAC5C,GAAG;AAAA,EACP;AACJ;AAGA,SAAS,UAAU,UAAkB,MAAiC;AAClE,QAAM,MAAM,SAAS,QAAQ;AAC7B,MAAI,CAAC,IAAK,QAAO;AAEjB,QAAM,OAAO,IAAI,MAAM,KAAK,OAAK,EAAE,aAAa,QAAQ,EAAE,UAAU,IAAI;AACxE,MAAI,CAAC,KAAM,QAAO;AAElB,SAAO,KAAK,SAAS,KAAK,OAAK,EAAE,aAAa,QAAQ,EAAE,UAAU,IAAI,KAAK;AAC/E;AAGA,SAAS,gBAAgB,UAAkB,UAAuB,oBAAI,IAAI,GAAa;AACnF,MAAI,QAAQ,IAAI,QAAQ,EAAG,QAAO,MAAM,KAAK,OAAO;AACpD,UAAQ,IAAI,QAAQ;AAEpB,QAAM,MAAM,SAAS,QAAQ;AAC7B,MAAI,CAAC,IAAK,QAAO,MAAM,KAAK,OAAO;AAEnC,aAAW,WAAW,IAAI,UAAU;AAChC,oBAAgB,SAAS,OAAO;AAAA,EACpC;AAEA,SAAO,MAAM,KAAK,OAAO;AAC7B;AAGA,SAAS,kBAAkB,UAAkB,MAA8B;AACvE,QAAM,MAAM,SAAS,QAAQ;AAC7B,MAAI,CAAC,IAAK,QAAO,CAAC;AAElB,QAAM,aAAa,gBAAgB,QAAQ;AAC3C,QAAM,UAA0B,WAAW,QAAQ,CAAAC,UAAQ,SAASA,KAAI,GAAG,SAAS,CAAC,CAAC;AAEtF,QAAM,SAAS,UAAU,UAAU,IAAI;AACvC,MAAI,QAAQ;AACR,YAAQ,KAAK,GAAG,OAAO,WAAW,QAAQ;AAC1C,YAAQ,KAAK,GAAG,OAAO,MAAM;AAAA,EACjC;AAEA,SAAO;AACX;AAGO,SAAS,4BAA4B,MAAc,UAAkB,MAAwB;AAChG,MAAI,SAAS,kBAAkB,UAAU,IAAI,EAAE,KAAK,OAAK,EAAE,SAAS,IAAI;AAExE,MAAI,CAAC,QAAQ;AACT,eAAW,OAAO,UAAU;AACxB,eAAS,kBAAkB,KAAK,IAAI,EAAE,KAAK,OAAK,EAAE,SAAS,IAAI;AAC/D,UAAI,OAAQ;AAAA,IAChB;AAAA,EACJ;AAEA,MAAI,CAAC,QAAQ;AACT,UAAM,IAAI,MAAM,2BAA2B,IAAI,uBAAuB,QAAQ,IAAI,IAAI,EAAE;AAAA,EAC5F;AAEA,SAAO,IAAI,wBAAS,mBAAI,KAAK,OAAO,WAAW,QAAQ,GAAG,IAAI,wBAAS,OAAO,MAAM,CAAC,CAAC;AAC1F;;;AO5GO,IAAM,8BAAN,MAAM,6BACb;AAAA,EACI;AAAA,SAAwB,cAAc;AAAA;AAAA,EAE/B,kBAAkB,UAAwB,UAA8C;AAE7F,UAAM,WAAW,SAAS,OAAO,SAAS,IAAI,EAAE;AAChD,UAAM,YAAY,SAAS;AAE3B,UAAM,QAAQ,6BAA4B,YAAY,KAAK,SAAS,MAAM,GAAG,SAAS,IAAI,SAAS,MAAM,SAAS,CAAC;AACnH,QAAI,CAAC,MAAO;AAGZ,UAAM,CAAC,MAAM,IAAI,MAAM,CAAC,EAAE,MAAM,GAAG;AACnC,WAAO,4BAA4B,QAAQ,SAAS,IAAI,QAAQ,SAAS,IAAI;AAAA,EAC/E;AACJ;;;ACnBA,IAAAC,iBAAyF;;;ACCzF,IAAAC,MAAoB;AAIb,IAAM,cAAN,MAAM,aAAY;AAAA,EAKb,YAAY,UAAkB,WAAiC,WAAiC;AAHxG,SAAgB,YAAkC,CAAC;AACnD,SAAgB,YAAkC,CAAC;AAG/C,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,YAAY;AAAA,EACrB;AAAA,EAEA,OAAc,aAAa,KAAgC;AACvD,UAAM,WAAW,IAAI,IAAI;AACzB,UAAM,OAAO,IAAI,QAAQ;AACzB,UAAM,QAAQ,KAAK,MAAM,OAAO;AAEhC,UAAM,YAAkC,CAAC;AACzC,UAAM,YAAkC,CAAC;AAEzC,UAAM,QAAQ,CAAC,MAAM,MAAM;AAEvB,YAAM,gBAAgB,KAAK,MAAM,4BAA4B;AAC7D,UAAI,eAAe;AACf,kBAAU,KAAK;AAAA,UACX,MAAM,cAAc,CAAC;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAGA,YAAM,gBAAgB,KAAK,MAAM,gCAAgC;AACjE,UAAI,eAAe;AACf,kBAAU,KAAK;AAAA,UACX,MAAM,cAAc,CAAC;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAGA,YAAM,WAAW,KAAK,MAAM,sBAAsB;AAClD,UAAI,UAAU;AACV,kBAAU,KAAK;AAAA,UACX,MAAM,SAAS,CAAC;AAAA,UAChB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAGA,YAAM,YAAY,KAAK,MAAM,2BAA2B;AACxD,UAAI,WAAW;AACX,kBAAU,KAAK;AAAA,UACX,MAAM,UAAU,CAAC;AAAA,UACjB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAED,WAAO,IAAI,aAAY,UAAU,WAAW,SAAS;AAAA,EACzD;AAAA,EAEA,aAAoB,KAAK,UAAwC;AAC7D,UAAM,UAAa,iBAAa,UAAU,MAAM;AAChD,UAAM,QAAQ,QAAQ,MAAM,OAAO;AAEnC,UAAM,YAAkC,CAAC;AACzC,UAAM,YAAkC,CAAC;AAEzC,UAAM,QAAQ,CAAC,MAAM,MAAM;AACvB,YAAM,gBAAgB,KAAK,MAAM,4BAA4B;AAC7D,UAAI,eAAe;AACf,kBAAU,KAAK;AAAA,UACX,MAAM,cAAc,CAAC;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAEA,YAAM,gBAAgB,KAAK,MAAM,gCAAgC;AACjE,UAAI,eAAe;AACf,kBAAU,KAAK;AAAA,UACX,MAAM,cAAc,CAAC;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAEA,YAAM,WAAW,KAAK,MAAM,sBAAsB;AAClD,UAAI,UAAU;AACV,kBAAU,KAAK;AAAA,UACX,MAAM,SAAS,CAAC;AAAA,UAChB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAEA,YAAM,YAAY,KAAK,MAAM,2BAA2B;AACxD,UAAI,WAAW;AACX,kBAAU,KAAK;AAAA,UACX,MAAM,UAAU,CAAC;AAAA,UACjB,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAED,WAAO,IAAI,aAAY,UAAU,WAAW,SAAS;AAAA,EACzD;AACJ;;;ACvHA,IAAM,eAA4C,CAAC;AAE5C,IAAM,qBAAN,cAAiC,sBAAmC;AAAA,EACzE,cAAc;AACZ,UAAM,cAAc,kBAAkB,YAAY,YAAY;AAAA,EAChE;AACF;AAEA,eAAsB,uBAAsC;AAC1D,SAAO,OAAO,cAAc,MAAM,sBAAsB,YAAY,IAAI,CAAC;AAC3E;AAEO,SAAS,4BAA4B,MAAc,UAA6C;AACrG,SAAO,eAAe,MAAM,UAAU,cAAc,OAAK,EAAE,SAAS;AACtE;AAEO,SAAS,4BAA4B,MAAc,UAA6C;AACrG,SAAO,eAAe,MAAM,UAAU,cAAc,OAAK,EAAE,SAAS;AACtE;;;AFpBO,IAAM,gCAAN,MAAM,+BAA4D;AAAA,EACrE;AAAA,SAAwB,oBAAoB;AAAA;AAAA,EAErC,kBAAkB,UAAwB,UACjD;AACE,UAAM,WAAW,SAAS,OAAO,SAAS,IAAI,EAAE;AAGhD,QAAI,CAAC,SAAS,UAAU,EAAE,WAAW,GAAG,EAAG;AAG3C,UAAM,QAAQ,+BAA8B,kBAAkB,KAAK,QAAQ;AAC3E,QAAI,CAAC,MAAO;AAGZ,UAAM,eAAe,MAAM,CAAC;AAC5B,UAAM,SAAS,4BAA4B,cAAc,SAAS,IAAI,MAAM;AAC5E,QAAI,CAAC,OAAQ;AAGb,WAAO,IAAI,wBAAS,mBAAI,KAAK,OAAO,QAAQ,GAAG,IAAI,wBAAS,OAAO,MAAM,CAAC,CAAC;AAAA,EAC7E;AACJ;;;AGzBA,IAAAC,iBAAwI;AAGjI,IAAM,2BAAN,MAAM,0BACb;AAAA,EACI;AAAA,SAAwB,gBAAgB;AAAA;AAAA,EACxC;AAAA,SAAwB,qBAAqB;AAAA;AAAA,EAEtC,uBAAwB,UAAwB,UAAuC;AAG1F,UAAM,WAAW,SAAS,QAAQ,IAAI;AAAA,MAClC,SAAS,KAAK,SAAS,MAAM,CAAC;AAAA,MAC9B;AAAA,IACJ,CAAC;AAED,QAAI,CAAC,0BAAyB,cAAc,KAAK,QAAQ,EAAG;AAC5D,QAAI,0BAAyB,mBAAmB,KAAK,QAAQ,EAAG;AAEhE,WAAO,2BAA2B,SAAS,IAAI,QAAQ,SAAS,IAAI;AAAA,EACxE;AACJ;;;ACrBA,IAAAC,iBAAyF;AAGlF,IAAM,gCAAN,MAAkE;AAAA,EAC9D,kBAAkB,UAAwB,UACjD;AACI,UAAM,YAAY,SAAS,uBAAuB,QAAQ;AAC1D,QAAI,CAAC,UAAW;AAEhB,UAAM,eAAe,SAAS,QAAQ,SAAS;AAC/C,QAAI,CAAC,aAAc;AAEnB,UAAM,SAAS,4BAA4B,cAAc,SAAS,IAAI,MAAM;AAC5E,QAAI,CAAC,OAAQ;AAEb,WAAO,IAAI,wBAAS,mBAAI,KAAK,OAAO,QAAQ,GAAG,IAAI,wBAAS,OAAO,MAAM,CAAC,CAAC;AAAA,EAC/E;AACJ;;;ACjBA,IAAAC,iBAAmC;AAG5B,IAAM,4BAAN,MACP;AAAA,EAGI,YAA8B,aAC9B;AAD8B;AAE1B,SAAK,YAAY,gBAAgB;AAEjC,UAAM,gBAA8B;AAAA,MAChC,sBAAO,+BAA+B,KAAK,UAAU,IAAI;AAAA,MACzD,sBAAO,4BAA4B,KAAK,UAAU,IAAI;AAAA,IAC1D;AAEA,SAAK,cAAc,0BAAW,KAAK,GAAG,aAAa;AAAA,EACvD;AAAA,EAEQ,WACR;AACI,SAAK,YAAY,gBAAgB;AAAA,EACrC;AAAA,EAEO,UACP;AACI,SAAK,YAAY,QAAQ;AAAA,EAC7B;AACJ;;;AC1BA,IAAAC,iBAA0D;AAKnD,IAAM,qBAAN,MAAyB;AAAA,EAGpB,OAAQ,GAAW,MAC3B;AACI,WAAO,GAAG,CAAC,IAAI,IAAI,GAAG,MAAM,IAAI,KAAK,GAAG;AAAA,EAC5C;AAAA,EAEO,kBACP;AAEI,UAAM,SAAS,sBAAO;AACtB,QAAI,CAAC,QACL;AACI,WAAK,eAAe,KAAK;AACzB;AAAA,IACJ;AAGA,UAAM,MAAM,OAAO;AACnB,QAAI,IAAI,eAAe,OACvB;AACI,WAAK,eAAe,KAAK;AACzB;AAAA,IACJ;AAGA,QAAI,CAAC,KAAK,gBACV;AACI,WAAK,iBAAiB,sBAAO,oBAAoB,kCAAmB,IAAI;AAAA,IAC5E;AAEA,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,YAAY,KAAK,cAAc,UAAU;AAC/C,UAAM,YAAY,KAAK,cAAc,UAAU;AAG/C,SAAK,eAAe,OAAO,aAAa,KAAK,OAAO,WAAW,MAAM,CAAC,OAAO,KAAK,OAAO,WAAW,MAAM,CAAC;AAC3G,SAAK,eAAe,KAAK;AAAA,EAC7B;AAAA,EAEQ,cAAc,SACtB;AACI,UAAM,QAAQ,QAAQ,MAAM,IAAI;AAEhC,UAAM,UAAU,KAAK,sBAAsB,KAAK,EAC/C,IAAI,UAAQ,KAAK,wBAAwB,IAAI,CAAC,EAC9C,OAAO,UAAQ,KAAK,iBAAiB,IAAI,CAAC;AAE3C,UAAM,OAAO,QAAQ,KAAK,GAAG;AAC7B,WAAO,KACJ,MAAM,KAAK,EACX,OAAO,UAAQ,KAAK,KAAK,IAAI,CAAC,EAAE;AAAA,EACvC;AAAA,EAEQ,wBAAwB,MAChC;AAEI,WAAO,KAAK,QAAQ,WAAW,EAAE;AAGjC,WAAO,KAAK,QAAQ,YAAY,EAAE;AAGlC,WAAO,KAAK,QAAQ,gBAAgB,EAAE;AAEtC,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA,EAEQ,iBAAiB,MACzB;AACI,QAAI,KAAK,KAAK,EAAE,WAAW,EAAG,QAAO;AACrC,QAAI,iCAAiC,KAAK,IAAI,EAAG,QAAO;AACxD,WAAO;AAAA,EACX;AAAA,EAEQ,sBAAsB,OAC9B;AACI,QAAI,UAAU;AACd,QAAI,YAAY;AAChB,UAAM,SAAmB,CAAC;AAE1B,aAAS,QAAQ,OAAO;AACtB,UAAI,SAAS;AACX,YAAI,KAAK,SAAS,GAAG,GAAG;AACtB,oBAAU;AACV,iBAAO,KAAK,MAAM,GAAG,EAAE,CAAC,KAAK;AAAA,QAC/B,MAAO;AAAA,MACT;AAEA,UAAI,WAAW;AACb,YAAI,KAAK,SAAS,IAAI,GAAG;AACvB,sBAAY;AACZ,iBAAO,KAAK,MAAM,IAAI,EAAE,CAAC,KAAK;AAAA,QAChC,MAAO;AAAA,MACT;AAEA,UAAI,KAAK,SAAS,IAAI,KAAK,CAAC,KAAK,SAAS,IAAI,GAAG;AAC/C,oBAAY;AACZ;AAAA,MACF;AAEA,UAAI,KAAK,SAAS,GAAG,KAAK,CAAC,KAAK,SAAS,GAAG,GAAG;AAC7C,kBAAU;AACV;AAAA,MACF;AAEA,aAAO,KAAK,IAAI;AAAA,IAClB;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,cAAe,YACtB;AACI,WAAO,WAAW,MAAM,IAAI,EAAE,OAAO,UAAQ,KAAK,MAAM,OAAO,CAAC,EAAE;AAAA,EACtE;AAAA,EAEO,UACP;AACI,SAAK,eAAe,QAAQ;AAAA,EAChC;AACJ;;;AfpHA,IAAM,MAAuB,EAAE,UAAU,MAAM;AAExC,SAAS,SAAS,SAA2B;AAChD,QAAM,cAAc,CAAC;AAGrB,QAAM,cAAc,IAAI,mBAAmB;AAC3C,QAAM,wBAAwB,IAAI,0BAA0B,WAAW;AACvE,QAAM,iBAAiB,IAAI,eAAe;AAC1C,QAAM,qBAAqB,IAAI,mBAAmB;AAGlD,cAAY,KAAK,aAAa,uBAAuB,gBAAgB,kBAAkB;AAGvF,GAAC,YAAY;AACT,QAAI;AACF,YAAM,QAAQ,IAAI;AAAA,QAChB,uBAAO,aAAa,EAAE,UAAU,iCAAiB,QAAQ,OAAO,gCAAgC,GAAG,gBAAgB;AAAA,QACnH,uBAAO,aAAa,EAAE,UAAU,iCAAiB,QAAQ,OAAO,mCAAmC,GAAG,oBAAoB;AAAA,MAC5H,CAAC;AAAA,IACH,SAAS,KAAK;AACZ,cAAQ,MAAM,wBAAwB,GAAG;AAAA,IAC3C;AAAA,EACJ,GAAG;AAGH,cAAY;AAAA,IACR,0BAAU,+BAA+B,KAAK,IAAI,yBAAyB,GAAG,KAAK,KAAK,GAAG;AAAA,IAC3F,0BAAU,2BAA2B,KAAK,IAAI,4BAA4B,CAAC;AAAA,IAC3E,0BAAU,2BAA2B,KAAK,IAAI,8BAA8B,CAAC;AAAA,IAC7E,0BAAU,2BAA2B,KAAK,IAAI,8BAA8B,CAAC;AAAA,EACjF;AAGA,UAAQ,cAAc,KAAK,GAAG,WAAW;AAC7C;","names":["import_vscode","import_vscode","import_vscode","import_vscode","path","fs","path","import_vscode","fs","import_vscode","import_vscode","import_vscode","import_vscode"]}